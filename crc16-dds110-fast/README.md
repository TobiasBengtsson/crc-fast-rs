# crc16-dds110-fast

SIMD implementation of CRC-16/DDS-110, with table and loop fallbacks.

This crate was generated by
[crc-fast-rs](https://github.com/TobiasBengtsson/crc-fast-rs).

## Principle of operation

TL;DR: uses SIMD if available, otherwise falls back seamlessly to a lookup table
algorithm.

- If using `hash`, will use SIMD if the CPU is capable
  - x86-64 CPU:s with the following CPU flags are supported (runtime detection):
    - `pclmulqdq`
    - `sse4.1`
  - aarch64 CPU:s with the following CPU flags are supported:
    - `nano`
    - `aes`
  - **IMPORTANT**: To use runtime CPU feature detection on aarch64, the `std`
    feature is required. Otherwise it has to be built with a compatible
    target-cpu to use SIMD, unlike x86-64.
- If using `hash` with an incompatible CPU the fallback algorithm will be
  invoked. If the `table-fallback` feature is active the fallback is based on
  a lookup table, otherwise a simple loop (slowest option). Deactivating
  `table-fallback` (default enabled) can be useful when memory is very scarce,
  as the lookup table requires a small amount of extra RAM.
- If `table-fallback` feature is enabled, it can be manually invoked by
  `hash_table` (not recommended in the typical case).
- Similarly, `hash_simple` can be used to force the loop algorithm (also not
  recommended in the typical case).

## Usage

```
let res: u32 = crc16_dds110_fast::hash(&my_binary_slice);
```

There is no "update"-like functionality yet, since doing this with arbitrarily
lengths can be tricky with SIMD and destroy performance.
